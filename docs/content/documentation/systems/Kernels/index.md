<!-- MOOSE Documentation Stub: Remove this when content is added. -->

# Kernels System

A "Kernel" is a piece of physics. It can represent one or more operators or
terms in the weak form of a partial differential equation.  With all terms on
the left-hand-side, their sum is referred to as the "residual". The residual
is evaluated at several integration quadrature points over the problem
mesh/geometry. To implement your own physics in MOOSE, you create your own
kernel by subclassing the MOOSE `Kernel` class.  In a `Kernel` subclass:

The `computeQpResidual()` function MUST be overridden.  This is where you
implement your PDE weak form terms.  The following member functions can
optionally be overriden/provided:

* `computeQpJacobian()`
* `computeQpOffDiagJacobian()`

These two functions provide extra information that can help the numerical
solver(s) converge faster and better.  Inside your Kernel class, you have
access to several member variables for computing the residual and jacobian
values in the above mentioned functions:

* `_i`, `_j`: indices for the current test and trial shape functions respectively.
* `_qp`: current quadrature point index.
* `_u`, `_grad_u`: value and gradient of the variable this Kernel operates on;
  indexed by `_qp` (i.e. `_u[_qp]`).
* `_test`, `_grad_test`: value ($\psi$) and gradient ($\nabla \psi$) of the
  test functions at the q-points; indexed by `_i` and then `_qp` (i.e. `_test[_i][_qp]`).
* `_phi`, `_grad_phi`: value ($\phi$) and gradient ($\nabla \phi$) of the
    trial functions at the q-points; indexed by `_j` and then `_qp` (i.e. `_phi[_j][_qp]`).
* `_q_point`: XYZ coordinates of the current quadrature point.
* `_current_elem`: pointer to the current element being operated on.

## Custom Kernel Creation

To create a custom kernel, you can follow the pattern of the `Diffusion`
kernel implemented and included in the MOOSe framework.  The strong-form of
the diffusion equations is defined as:

$$
\begin{aligned}
-\nabla\cdot\nabla u - f &= 0\\
u|_{\partial\Omega_1} &= g_1\\
\nabla u\cdot \hat{n} |_{\partial\Omega_2} &= g_2\end{aligned}
$$

The weak form is generated by multiplying by a test function and integrating
over the domain:

$$ (-\nabla\cdot\nabla u, \psi_i) - (f, \psi_i) = 0 $$

and then integrating by parts which gives the weak form:

$$ (\nabla u, \nabla \psi_i) - (f, \psi_i) - \langle g_2, \psi_i\rangle = 0 $$

The Jacobian is defined as:

$$ (\nabla \phi_j, \nabla \psi_i)$$

The diffusion kernel header and implementation files are:

!text framework/src/kernels/Diffusion.h max-height=400px

!text framework/src/kernels/Diffusion.C max-height=400px

Before a custom physics kernel is available for use, it must be registered.
This is done in e.g. `src/base/YourApp.C` for the YourApp application.

```cpp
// src/base/YourApp.C contents

#include "YourKernel.h"

...

int YourApp::registerObjects(Factory & factory)
{
  ...
  registerKernel(YourKernel);
  ...
}

...
```

Example 2 provides a step-by-step overview of creating your own custom kernel.
TODO: link to example 2 documentation when it gets migrated

## Time Derivative Kernels

You can create a time-derivative term/kernel by subclassing `TimeKernel`
instead of `Kernel`.  For example, the residual contribution for a time
derivative term is:

$$\left(\frac{\partial u_h}{\partial t}, \psi_i\right)$$

where $u_h$ is the finite element solution, and

$$
\frac{\partial u_h}{\partial t}
\equiv
\frac{\partial}{\partial t}
\left(
    \sum_k u_k \phi_k
\right)
= \sum_k \frac{\partial u_k}{\partial t} \phi_k
$$

because you can interchange the order of differentiation and summation.  Call
this equation (1).

In the equation above, $\frac{\partial u_k}{\partial t}$ is the time
derivative of the $k$th finite element coefficient of $u_h$. While the
exact form of this derivative depends on the time stepping scheme, without
much loss of generality, we can assume the following form for the time
derivative:

$$ \frac{\partial u_k}{\partial t} = a u_k + b $$

for some constants $a$, $b$ which depend on $\Delta t$ and the timestepping method.

The derivative of (1) with respect to $u_j$ is then:

$$
\frac{\partial}{\partial u_j} \left(
    \sum_k \frac{\partial u_k}{\partial t} \phi_k
\right) =
\frac{\partial }{\partial u_j} \left(
    \sum_k (a u_k + b) \phi_k
\right)
 = a \phi_j
$$

So that the jacobian term for (1) is

$$\left(a \phi_j, \psi_i\right)$$

where $a$ is what we call `du_dot_du` in MOOSE.

Therefore the `computeQpResidual()` function for our time-derivative term
kernel looks like:

```cpp
return _test[_i][_qp]*_u_dot[_qp];
```

And the corresponding `computeQpJacobian()` is:

```cpp
return _test[_i][_qp]*_phi[_j][_qp]*_du_dot_du[_qp];
```

## Further Kernel Documentation

Several specialized kernel types exist in MOOSE each with useful
functionality.  Details for each are in the sections below.

!parameters /Kernels

!subobjects /Kernels

